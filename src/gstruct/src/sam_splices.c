static char rcsid[] = "$Id: sam_splices.c 47710 2011-09-19 22:16:07Z twu $";
/* Note: Handles only paired-end data */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>		/* Needed to define pthread_t on Solaris */
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>		/* For strcpy */
#include <strings.h>		/* For rindex */
#include <ctype.h>
#include <math.h>		/* For qsort */

#include "except.h"
#include "mem.h"
#include "bool.h"
#include "chrom.h"
#include "genomicpos.h"
#include "intlist.h"
#include "uintlist.h"
#include "list.h"
#include "iit-read.h"
#include "interval.h"
#include "table.h"
#include "uinttable.h"
#include "datadir.h"
#include "getopt.h"

#ifdef BAM_INPUT
#include "bamread.h"
#endif

#include "samflags.h"
#include "samread.h"
#include "genome.h"
#include "complement.h"
#include "tally.h"


#ifdef DEBUG
#define debug(x) x
#else
#define debug(x)
#endif

/* Parsing SAM */
#ifdef DEBUG0
#define debug0(x) x
#else
#define debug0(x)
#endif

/* Adding splices and sites to graph */
#ifdef DEBUG1
#define debug1(x) x
#else
#define debug1(x)
#endif

/* Monitoring progress */
#ifdef DEBUG2
#define debug2(x) x
#else
#define debug2(x)
#endif


static char *user_genomedir = NULL;
static char *dbroot = NULL;
static char *dbversion = NULL;

static bool allow_translocations_p = false;

static bool trust_sam_p = true;
static bool need_concordant_p = false;
static bool need_canonical_p = false;

static bool uniquep = true;
static Genomicpos_T max_pairlength = 1000000;
static Genomicpos_T shortsplicedist = 200000;
static int max_exonlength = 500;

static int mincount = 1;
static int minsupport = 1;


static struct option long_options[] = {
  /* Input options */
#if 0
  {"chr", required_argument, 0, 'c'}, /* chromosome */
#endif

  {"concordant", required_argument, 0, 'C'}, /* need_concordant_p */
  {"unique", required_argument, 0, 'U'}, /* uniquep */

  {"pairmax", required_argument, 0, 'P'}, /* max_pairlength */

  /* Help options */
  {"version", no_argument, 0, 'V'}, /* print_program_version */
  {"help", no_argument, 0, '?'}, /* print_program_usage */
  {0, 0, 0, 0}
};


static void
print_program_version () {
  fprintf(stdout,"\n");
  fprintf(stdout,"SAM_EXTENTS\n");
  fprintf(stdout,"Part of GSTRUCT package, version %s\n",PACKAGE_VERSION);
  fprintf(stdout,"Build target: %s\n",TARGET);
  fprintf(stdout,"Default gmap directory: %s\n",GMAPDB);
  fprintf(stdout,"Thomas D. Wu, Genentech, Inc.\n");
  fprintf(stdout,"Contact: twu@gene.com\n");
  fprintf(stdout,"\n");
  return;
}


static void
print_program_usage () {
  fprintf(stdout,"\
Usage: cat <SAM output> | sam_extents [-d <genome>] [OPTIONS...]\n\
\n\
Note: If SAM output contains XS: tags (generated by GSNAP, for example),\n\
      to indicate the genomic strands of splices, then the -d flag is not necessary\n\
\n\
Input options\n\
  -u, --unique=INT               Unique hits only (0=no, 1=yes [default])\n\
  -P, --pairmax=INT              Maximum pairlength\n\
  -9, --dump                     Dump graph\n\
\n\
");

  return;
}


/************************************************************************
 *   Extents
 ************************************************************************/

typedef struct Extent_T *Extent_T;
struct Extent_T {
  int count;
  int nunique;

  Genomicpos_T low;
  Genomicpos_T high;
};

static void
Extent_free (Extent_T *old) {
  FREE(*old);
  return;
}


static int
Extent_cmp (const void *a, const void *b) {
  Extent_T x = * (Extent_T *) a;
  Extent_T y = * (Extent_T *) b;

  if (x->low < y->low) {
    return -1;
  } else if (y->low < x->low) {
    return +1;
  } else if (x->high < y->high) {
    return -1;
  } else if (y->high < x->high) {
    return +1;
  } else {
    return 0;
  }
}

#if 0
static int
Extent_high_cmp (const void *a, const void *b) {
  Extent_T x = * (Extent_T *) a;
  Extent_T y = * (Extent_T *) b;

  if (x->high < y->high) {
    return -1;
  } else if (y->high < x->high) {
    return +1;
  } else {
    return 0;
  }
}
#endif

#if 0
static int
Extent_count_cmp (const void *a, const void *b) {
  Extent_T x = * (Extent_T *) a;
  Extent_T y = * (Extent_T *) b;

  if (x->count > y->count) {
    return -1;
  } else if (y->count >  x->count) {
    return +1;
  } else {
    return 0;
  }
}
#endif


#if 0
static List_T
Extent_cumulate_counts (List_T extents) {
  long int total_up, total_down;
  List_T p;
  Extent_T extent;

  total_up = 0;
  for (p = extents; p != NULL; p = List_next(p)) {
    extent = (Extent_T) List_head(p);
    total_up += extent->count;
    extent->total_up = total_up;
  }

  extents = List_reverse(extents);

  total_down = 0;
  for (p = extents; p != NULL; p = List_next(p)) {
    extent = (Extent_T) List_head(p);
    total_down += extent->count;
    extent->total_down = total_down;
  }

  return List_reverse(extents);
}
#endif


static List_T
Extent_add_at_low (List_T list, Genomicpos_T low, Genomicpos_T high, int nhits) {
  List_T p;
  Extent_T extent;

  debug1(printf("List has %d elements currently\n",List_length(list)));

  if (high - low > max_pairlength) {
    debug1(printf("pair is too long, so skipping\n"));
    return list;

  } else {
    for (p = list; p != NULL; p = List_next(p)) {
      extent = (Extent_T) List_head(p);
      debug1(printf("  Comparing high %u with list high %u",high,extent->high));
      if (extent->high == high) {
	extent->count += 1;
	if (nhits == 1) {
	  extent->nunique += 1;
	}
	debug1(printf("  equal, so count is now %d\n",extent->count));
	return list;
      }
      debug1(printf("\n"));
    }

    /* Not found, so add to list */
    debug1(printf("High not found, so creating new extent\n"));
    extent = (Extent_T) MALLOC(sizeof(*extent));
    extent->count = 1;
    extent->nunique = 0;
    if (nhits == 1) {
      extent->nunique += 1;
    }
    extent->low = low;
    extent->high = high;

    return List_push(list,extent);
  }
}


/************************************************************************
 *   Bamstore
 ************************************************************************/

#ifdef BAM_INPUT
typedef struct Bamstore_T *Bamstore_T;
struct Bamstore_T {
  Genomicpos_T chrpos;
  List_T bamlines;
};

static void
Bamstore_free (Bamstore_T *old) {
  List_T p;
  Bamline_T bamline;

  for (p = (*old)->bamlines; p != NULL; p = List_next(p)) {
    bamline = (Bamline_T) List_head(p);
    Bamline_free(&bamline);
  }
  List_free(&(*old)->bamlines);

  FREE(*old);
  return;
}


static Bamstore_T
Bamstore_new (Genomicpos_T chrpos) {
  Bamstore_T new = (Bamstore_T) MALLOC(sizeof(*new));

  new->chrpos = chrpos;
  new->bamlines = (List_T) NULL;

  return new;
}



static Bamline_T
Bamstore_get (Table_T bamstore_chrtable, char *chr, Genomicpos_T low, char *acc,
	      Genomicpos_T mate_low) {
  List_T p, list = NULL;
  Bamline_T wanted = NULL, bamline;
  Bamstore_T bamstore;
  Uinttable_T bamstore_table;
  Chrom_T chrom;

  chrom = Chrom_from_string(chr,/*mitochondrial_string*/NULL,/*order*/0U);
  if ((bamstore_table = (Uinttable_T) Table_get(bamstore_chrtable,(void *) chrom)) == NULL) {
    fprintf(stderr,"Unexpected error.  No bamstore_table for chr %s\n",chr);
    abort();
  } else {
    Chrom_free(&chrom);
  }

  if ((bamstore = (Bamstore_T) Uinttable_get(bamstore_table,low)) == NULL) {
    /* May have been excluded for other reasons */
    return (Bamline_T) NULL;
  } else {
    for (p = bamstore->bamlines; p != NULL; p = List_next(p)) {
      bamline = (Bamline_T) List_head(p);
      if (strcmp(Bamline_acc(bamline),acc) == 0 && Bamline_mate_chrpos_low(bamline) == mate_low) {
	wanted = bamline;
      } else {
	list = List_push(list,(void *) bamline);
      }
    }

    List_free(&bamstore->bamlines);
    bamstore->bamlines = list;
    if (list == NULL) {
      Uinttable_remove(bamstore_table,low);
      Bamstore_free(&bamstore);
    }

    return wanted;
  }
}
  

static void
Bamstore_add_at_low (Table_T bamstore_chrtable, char *chr, Genomicpos_T low,
		     Bamline_T bamline) {
  Bamstore_T bamstore;
  Uinttable_T bamstore_table;
  Chrom_T chrom;

  chrom = Chrom_from_string(chr,/*mitochondrial_string*/NULL,/*order*/0U);
  if ((bamstore_table = (Uinttable_T) Table_get(bamstore_chrtable,(void *) chrom)) == NULL) {
    debug1(printf("Made new bamstore_table for chr %s\n",chr));
    bamstore_table = Uinttable_new(65522); /* estimate 65522 splice sites per chromosome */
    Table_put(bamstore_chrtable,(void *) chrom,(void *) bamstore_table);
  } else {
    Chrom_free(&chrom);
  }

  if ((bamstore = (Bamstore_T) Uinttable_get(bamstore_table,low)) == NULL) {
    debug1(printf("Made new bamstore\n"));
    bamstore = Bamstore_new(low);
    Uinttable_put(bamstore_table,low,(void *) bamstore);
  }

  bamstore->bamlines = List_push(bamstore->bamlines,(void *) bamline);
  return;
}


static void
Bamstore_table_free (Uinttable_T bamstore_table) {
  Genomicpos_T *keys;
  int n, i;
  Bamstore_T bamstore;

  if ((n = Uinttable_length(bamstore_table)) > 0) {
    keys = (Genomicpos_T *) Uinttable_keys(bamstore_table,/*sortp*/false);
    for (i = 0; i < n; i++) {
      bamstore = Uinttable_get(bamstore_table,keys[i]);
      if (bamstore == NULL) {
	fprintf(stderr,"key is %u, value is NULL\n",keys[i]);
	abort();
      } else {
	Bamstore_free(&bamstore);
      }
    }
    FREE(keys);
  }

  return;
}


#endif


/************************************************************************
 *   Splices
 ************************************************************************/

typedef struct Splice_T *Splice_T;
struct Splice_T {
  int count;
  int nunique;
  int maxminsupport;

  int sign;
  Genomicpos_T donorpos;
  Genomicpos_T acceptorpos;
  Genomicpos_T low;
  Genomicpos_T high;

  bool canonicalp;
  char donor1;
  char donor2;
  char acceptor1;
  char acceptor2;

  int alpha;
  int omega;

  bool boundedp;
};

static void
Splice_free (Splice_T *old) {
  FREE(*old);
  return;
}

static Splice_T *
Splice_array_copy (Splice_T *array, int nsplices) {
  Splice_T *copy;
  int i;

  if (nsplices == 0) {
    return (Splice_T *) NULL;
  } else {
    copy = (Splice_T *) CALLOC(nsplices,sizeof(Splice_T));
    for (i = 0; i < nsplices; i++) {
      copy[i] = array[i];
    }
    return copy;
  }
}


static int
Splice_cmp (const void *a, const void *b) {
  Splice_T x = * (Splice_T *) a;
  Splice_T y = * (Splice_T *) b;

  if (x->donorpos < y->donorpos) {
    return -1;
  } else if (y->donorpos < x->donorpos) {
    return +1;
  } else if (x->acceptorpos < y->acceptorpos) {
    return -1;
  } else if (y->acceptorpos < x->acceptorpos) {
    return +1;
  } else {
    return 0;
  }
}

static int
Splice_low_cmp (const void *a, const void *b) {
  Splice_T x = * (Splice_T *) a;
  Splice_T y = * (Splice_T *) b;

  if (x->low < y->low) {
    return -1;
  } else if (y->low < x->low) {
    return +1; 
  } else {
    return 0;
  }
}

static int
Splice_high_cmp (const void *a, const void *b) {
  Splice_T x = * (Splice_T *) a;
  Splice_T y = * (Splice_T *) b;

  if (x->high > y->high) {
    return -1;
  } else if (y->high > x->high) {
    return +1;
  } else {
    return 0;
  }
}

static int
Splice_bycount_cmp (const void *a, const void *b) {
  Splice_T x = * (Splice_T *) a;
  Splice_T y = * (Splice_T *) b;

  if (x->count < y->count) {
    return -1;
  } else if (y->count < x->count) {
    return +1;
  } else {
    return 0;
  }
}


static List_T
Splice_add_at_donor (List_T list, int sign, Genomicpos_T donorpos, Genomicpos_T acceptorpos,
		     int nhits, int support1, int support2, bool canonicalp,
		     char donor1, char donor2, char acceptor1, char acceptor2) {
  List_T p;
  Splice_T splice;
  int minsupport;

  if (support1 < support2) {
    minsupport = support1;
  } else {
    minsupport = support2;
  }

  debug1(printf("List has %d elements currently\n",List_length(p)));
  for (p = list; p != NULL; p = List_next(p)) {
    splice = List_head(p);
    debug1(printf("  Comparing acceptorpos %u with list acceptorpos %u",
		  acceptorpos,splice->acceptorpos));
    if (splice->acceptorpos == acceptorpos) {
      splice->count += 1;
      if (nhits == 1) {
	splice->nunique += 1;
      }
      if (minsupport > splice->maxminsupport) {
	splice->maxminsupport = minsupport;
      }
      debug1(printf("  equal, so count is now %d\n",splice->count));
      return list;
    }
    debug1(printf("\n"));
  }

  /* Not found, so add to list */
  debug1(printf("Acceptorpos not found, so creating new splice\n"));
  splice = (Splice_T) MALLOC(sizeof(*splice));
  splice->count = 1;
  splice->nunique = 0;
  if (nhits == 1) {
    splice->nunique += 1;
  }
  splice->maxminsupport = minsupport;

  splice->sign = sign;
  splice->donorpos = donorpos;
  splice->acceptorpos = acceptorpos;
  if (sign > 0) {
    splice->low = donorpos;
    splice->high = acceptorpos;
  } else if (sign < 0) {
    splice->low = acceptorpos;
    splice->high = donorpos;
  } else {
    fprintf(stderr,"sign is 0\n");
    abort();
  }

  splice->canonicalp = canonicalp;
  splice->donor1 = donor1;
  splice->donor2 = donor2;
  splice->acceptor1 = acceptor1;
  splice->acceptor2 = acceptor2;
  splice->boundedp = true;

  return List_push(list,splice);
}


/************************************************************************
 *   Sites
 ************************************************************************/

typedef struct Site_T *Site_T;
struct Site_T {
  Genomicpos_T chrpos;
  List_T intervals;
};


static void
Site_free_extent (Site_T *old) {
  List_T p;
  Extent_T extent;

  for (p = (*old)->intervals; p != NULL; p = List_next(p)) {
    extent = (Extent_T) List_head(p);
    Extent_free(&extent);
  }
  List_free(&(*old)->intervals);

  FREE(*old);
  return;
}

static void
Site_free_splice (Site_T *old) {
  List_T p;
  Splice_T splice;

  for (p = (*old)->intervals; p != NULL; p = List_next(p)) {
    splice = (Splice_T) List_head(p);
    Splice_free(&splice);
  }
  List_free(&(*old)->intervals);

  FREE(*old);
  return;
}


static Site_T
Site_new (Genomicpos_T chrpos) {
  Site_T new = (Site_T) MALLOC(sizeof(*new));

  new->chrpos = chrpos;
  new->intervals = (List_T) NULL;

  return new;
}


static void
Site_print_extent (Site_T this, char *chr) {
  Extent_T extent, *array;
  int n, i;
  
  n = List_length(this->intervals);
  if (n > 0) {
    array = (Extent_T *) List_to_array(this->intervals,NULL);
    qsort(array,n,sizeof(Extent_T),Extent_cmp);
    for (i = 0; i < n; i++) {
      extent = array[i];
      printf(">%d %s:%u..%u nunique:%d",
	     extent->count,chr,extent->low,extent->high,
	     extent->nunique);
      printf("\n");

    }
    FREE(array);
  }

  return;
}

static void
Splice_print (Splice_T splice, char *chr) {
  if (splice->boundedp == true && splice->count >= mincount && splice->maxminsupport >= minsupport) {
    printf(">%d %s:%u..%u nunique:%d",
	   splice->count,chr,splice->donorpos,splice->acceptorpos,
	   splice->nunique);
    printf(" maxminsupport:%d",splice->maxminsupport);
    if (splice->canonicalp == false) {
      printf(" %c%c-%c%c",splice->donor1,splice->donor2,splice->acceptor1,splice->acceptor2);
    }
    printf("\n");

#if 0
    if (splicesites_iit != NULL) {
      if (splice->donorpos < splice->acceptorpos) {
	print_splicesite_labels(chr,splice->donorpos,splice->donorpos+1U,splicesites_iit,
				donor_typeint);
	print_splicesite_labels(chr,splice->acceptorpos-1U,splice->acceptorpos,splicesites_iit,
				acceptor_typeint);
      } else if (splice->donorpos > splice->acceptorpos) {
	print_splicesite_labels(chr,splice->donorpos-1U,splice->donorpos,splicesites_iit,
				donor_typeint);
	print_splicesite_labels(chr,splice->acceptorpos,splice->acceptorpos+1U,splicesites_iit,
				acceptor_typeint);

      } else {
	fprintf(stderr,"Error: splice donorpos and acceptorpos are equal at %s:%u\n",
		chr,splice->donorpos);
	exit(9);
      }
    }
#endif
  }

  return;
}


static void
Site_print_splice (Site_T this, char *chr) {
  Splice_T *array;
  int n, i;
  
  n = List_length(this->intervals);
  if (n > 0) {
    array = (Splice_T *) List_to_array(this->intervals,NULL);
    qsort(array,n,sizeof(Splice_T),Splice_cmp);
    for (i = 0; i < n; i++) {
      Splice_print(array[i],chr);
    }
    FREE(array);
  }

  return;
}



static void
Site_add_at_low (Table_T fwd_extents_chrtable, Table_T rev_extents_chrtable,
		 char *chr, Genomicpos_T low, Genomicpos_T high,
		 int nhits, char strand) {
  Table_T chr_table = NULL;
  Site_T site;
  Uinttable_T sitetable;
  Chrom_T chrom;
  
  debug1(printf("Called Site_add_at_low with chr %s, low %u, high %u\n",
		chr,low,high));

  if (strand == '+') {
    chr_table = fwd_extents_chrtable;
  } else if (strand == '-') {
    chr_table = rev_extents_chrtable;
  }

  if (chr_table != NULL) {
    chrom = Chrom_from_string(chr,/*mitochondrial_string*/NULL,/*order*/0U);
    if ((sitetable = (Uinttable_T) Table_get(chr_table,(void *) chrom)) == NULL) {
      debug1(printf("Made new sitetable for chr %s\n",chr));
      sitetable = Uinttable_new(65522); /* estimate 65522 splice sites per chromosome */
      Table_put(chr_table,(void *) chrom,(void *) sitetable);
    } else {
      Chrom_free(&chrom);
    }

    if ((site = (Site_T) Uinttable_get(sitetable,low)) == NULL) {
      debug1(printf("Made new site\n"));
      site = Site_new(low);
      Uinttable_put(sitetable,low,(void *) site);
    }

    site->intervals = Extent_add_at_low(site->intervals,low,high,nhits);
  }

  return;
}

static void
Site_add_at_donor (Table_T chr_table, char *chr, int sign,
		   Genomicpos_T donorpos, Genomicpos_T acceptorpos,
		   int nhits, int support1, int support2, bool canonicalp,
		   char donor1, char donor2, char acceptor1, char acceptor2) {
  Site_T site;
  Uinttable_T sitetable;
  Chrom_T chrom;
  
  debug1(printf("Called Site_add_at_donor with chr %s, sign %d, donorpos %u, acceptorpos %u\n",
		chr,sign,donorpos,acceptorpos));

  chrom = Chrom_from_string(chr,/*mitochondrial_string*/NULL,/*order*/0U);
  if ((sitetable = (Uinttable_T) Table_get(chr_table,(void *) chrom)) == NULL) {
    debug1(printf("Made new sitetable for chr %s\n",chr));
    sitetable = Uinttable_new(65522); /* estimate 65522 splice sites per chromosome */
    Table_put(chr_table,(void *) chrom,(void *) sitetable);
  } else {
    Chrom_free(&chrom);
  }

  if ((site = (Site_T) Uinttable_get(sitetable,donorpos)) == NULL) {
    debug1(printf("Made new site\n"));
    site = Site_new(donorpos);
    Uinttable_put(sitetable,donorpos,(void *) site);
  }

  if (donorpos == 0 || acceptorpos == 0) {
    fprintf(stderr,"Unexpected donorpos %u or acceptorpos %u in sam_splices or gsnap_splices\n",
	    donorpos,acceptorpos);
    abort();
  }
  site->intervals = Splice_add_at_donor(site->intervals,sign,donorpos,acceptorpos,nhits,
					support1,support2,canonicalp,donor1,donor2,acceptor1,acceptor2);

  return;
}


/************************************************************************/

static char complCode[128] = COMPLEMENT_LC;

static void
find_dinucleotides (bool *canonicalp, char *donor1, char *donor2, char *acceptor1, char *acceptor2,
		    Genomicpos_T firstpos, Genomicpos_T secondpos, char *chr,
		    Genome_T genome, IIT_T chromosome_iit, char truestrand) {
  Chrnum_T chrnum;
  Genomicpos_T chroffset;
  char nt1, nt2, nt3, nt4;

  if (truestrand != ' ') {
    if (trust_sam_p == true) {
      *canonicalp = true;
      *donor1 = *donor2 = *acceptor1 = *acceptor2 = ' ';
      return;
    } else {
      chrnum = IIT_find_one(chromosome_iit,chr);
      chroffset = Interval_low(IIT_interval(chromosome_iit,chrnum)) - 1U;

      /* Look at genome inside of firstpos and secondpos to get dinucleotides */
      nt1 = Genome_get_char(genome,chroffset+firstpos+1);
      nt2 = Genome_get_char(genome,chroffset+firstpos+2);
      nt3 = Genome_get_char(genome,chroffset+secondpos-2);
      nt4 = Genome_get_char(genome,chroffset+secondpos-1);

      debug(printf("Got splice from %u to %u\n",firstpos,secondpos));
      debug(printf("Dinucleotides are %c%c to %c%c\n",nt1,nt2,nt3,nt4));

      if (truestrand == '+') {
	if (nt1 == 'G' && (nt2 == 'T' || nt2 == 'C') && nt3 == 'A' && nt4 == 'G') {
	  *canonicalp = true;
	} else if (nt1 == 'A' && nt2 == 'T' && nt3 == 'A' && nt4 == 'C') {
	  *canonicalp = true;
	} else {
	  *canonicalp = false;
	}
	*donor1 = nt1; *donor2 = nt2; *acceptor1 = nt3; *acceptor2 = nt4;

      } else if (truestrand == '-') {
	if (nt1 == 'C' && nt2 == 'T' && (nt3 == 'A' || nt3 == 'G') && nt4 == 'C') {
	  *canonicalp = true;
	} else if (nt1 == 'G' && nt2 == 'T' && nt3 == 'A' && nt4 == 'T') {
	  *canonicalp = true;
	} else {
	  *canonicalp = false;
	}
	*donor1 = complCode[(int) nt4]; *donor2 = complCode[(int) nt3]; *acceptor1 = complCode[(int) nt2]; *acceptor2 = complCode[(int) nt1];

      } else {
	fprintf(stderr,"Unrecognized truestrand %c\n",truestrand);
	abort();
      }

      return;
    }

  } else if (chromosome_iit == NULL) {
    fprintf(stderr,"To determine strand, need to provide index file with -d flag\n");
    exit(9);

  } else {
    chrnum = IIT_find_one(chromosome_iit,chr);
    chroffset = Interval_low(IIT_interval(chromosome_iit,chrnum)) - 1U;

    /* Look at genome inside of firstpos and secondpos to determine truestrand */
    nt1 = Genome_get_char(genome,chroffset+firstpos+1);
    nt2 = Genome_get_char(genome,chroffset+firstpos+2);
    nt3 = Genome_get_char(genome,chroffset+secondpos-2);
    nt4 = Genome_get_char(genome,chroffset+secondpos-1);

    debug(printf("Got splice from %u to %u\n",firstpos,secondpos));
    debug(printf("Dinucleotides are %c%c to %c%c\n",nt1,nt2,nt3,nt4));

    if (nt1 == 'G' && (nt2 == 'T' || nt2 == 'C') && nt3 == 'A' && nt4 == 'G') {
      *donor1 = nt1; *donor2 = nt2; *acceptor1 = nt3; *acceptor2 = nt4;
      *canonicalp = true;
      return;
    } else if (nt1 == 'C' && nt2 == 'T' && (nt3 == 'A' || nt3 == 'G') && nt4 == 'C') {
      *donor1 = complCode[(int) nt4]; *donor2 = complCode[(int) nt3]; *acceptor1 = complCode[(int) nt2]; *acceptor2 = complCode[(int) nt1];
      *canonicalp = true;
      return;
    } else if (nt1 == 'A' && nt2 == 'T' && nt3 == 'A' && nt4 == 'C') {
      *donor1 = nt1; *donor2 = nt2; *acceptor1 = nt3; *acceptor2 = nt4;
      *canonicalp = true;
      return;
    } else if (nt1 == 'G' && nt2 == 'T' && nt3 == 'A' && nt4 == 'T') {
      *donor1 = complCode[(int) nt4]; *donor2 = complCode[(int) nt3]; *acceptor1 = complCode[(int) nt2]; *acceptor2 = complCode[(int) nt1];
      *canonicalp = true;
      return;
    } else {
      /* In GSNAP, will want to output sense information in SAM output. */
#if 0
      fprintf(stderr,"Splice %s:%u..%u is not (semi-)canonical: %c%c...%c%c.  Cannot determine sense.\n",
	      chr,firstpos,secondpos,nt1,nt2,nt3,nt4);
#endif
      *donor1 = nt1; *donor2 = nt2; *acceptor1 = nt3; *acceptor2 = nt4;
      *canonicalp = false;
      return;
    }
  }
}


static void
add_splice (Genomicpos_T firstpos, Genomicpos_T secondpos,
	    char *chr, int nhits, int support1, int support2,
	    Table_T fwd_splices_chrtable, Table_T rev_splices_chrtable,
	    Genome_T genome, IIT_T chromosome_iit, char truestrand) {
  bool canonicalp;
  char donor1, donor2, acceptor1, acceptor2;
  Genomicpos_T donorpos, acceptorpos;

  if (truestrand == '+') {
    donorpos = firstpos;
    acceptorpos = secondpos;
  } else if (truestrand == '-') {
    donorpos = secondpos;
    acceptorpos = firstpos;
  } else {
    return;
  }

  find_dinucleotides(&canonicalp,&donor1,&donor2,&acceptor1,&acceptor2,
		     firstpos,secondpos,chr,genome,chromosome_iit,truestrand);

  debug0(printf("Got splice from %u to %u\n",donorpos,acceptorpos));
  if (truestrand == '+' && acceptorpos > donorpos + shortsplicedist) {
    /* Distance too far */
  } else if (truestrand == '-' && donorpos > acceptorpos + shortsplicedist) {
    /* Distance too far */
  } else if (truestrand == ' ' && secondpos > firstpos + shortsplicedist) {
    /* Distance too far */
  } else {
    debug(printf("%c%s:%u..%u\n",truestrand,chr,donorpos,acceptorpos));
    
    if (truestrand == '+') {
      Site_add_at_donor(fwd_splices_chrtable,chr,/*sign*/+1,donorpos,acceptorpos,nhits,
			support1,support2,canonicalp,donor1,donor2,acceptor1,acceptor2);
    } else if (truestrand == '-') {
      Site_add_at_donor(rev_splices_chrtable,chr,/*sign*/-1,donorpos,acceptorpos,nhits,
			support1,support2,canonicalp,donor1,donor2,acceptor1,acceptor2);
    } else if (truestrand == ' ') {
      if (need_canonical_p == false) {
	fprintf(stderr,"Adding splice at %s:%u..%u to both strands\n",chr,firstpos,secondpos);
	/* Add to both sides */
	Site_add_at_donor(fwd_splices_chrtable,chr,/*sign*/+1,/*donorpos*/firstpos,/*acceptorpos*/secondpos,
			  nhits,support1,support2,canonicalp,donor1,donor2,acceptor1,acceptor2);
	Site_add_at_donor(rev_splices_chrtable,chr,/*sign*/-1,/*donorpos*/secondpos,/*acceptorpos*/firstpos,
			  nhits,support1,support2,canonicalp,donor1,donor2,acceptor1,acceptor2);
      }
    }
  }

  return;
}


static int
get_support2 (Intlist_T types, Uintlist_T npositions) {
  int support2 = 0;
  Intlist_T p = types;
  Uintlist_T q = npositions;
  int type;
  
  while (p != NULL) {
    if ((type = Intlist_head(p)) == 'S') {
      /* Ignore */

    } else if (type == 'H') {
      /* Ignore */

    } else if (type == 'M') {
      support2 += Uintlist_head(q);

    } else if (type == 'N') {
      return support2;

    } else if (type == 'I') {
      support2 += Uintlist_head(q);

    } else if (type == 'D') {
      if (Uintlist_head(q) > 50) {
	return support2;
      } else {
	/* Do nothing */
      }

    } else {
      fprintf(stderr,"Cannot parse type %c\n",type);
      exit(9);
    }

    p = Intlist_next(p);
    q = Uintlist_next(q);
  }

  return support2;
}


static void
parse_splices (int nhits, char *chr, Genomicpos_T chrpos_low,
	       Intlist_T types, Uintlist_T npositions, char truestrand,
	       Table_T fwd_splices_chrtable, Table_T rev_splices_chrtable,
	       Genome_T genome, IIT_T chromosome_iit) {
  Genomicpos_T firstpos, secondpos, chrpos;
  int type;
  int support1, support2;
  Intlist_T p;
  Uintlist_T q;

  /* Get splice coordinates */
  chrpos = chrpos_low;
  support1 = 0;
  for (p = types, q = npositions; p != NULL; p = Intlist_next(p), q = Uintlist_next(q)) {
    if ((type = Intlist_head(p)) == 'S') {
      /* Ignore */

    } else if (type == 'H') {
      /* Ignore */

    } else if (type == 'M') {
      chrpos += Uintlist_head(q);
      support1 += Uintlist_head(q);

    } else if (type == 'N') {
      firstpos = chrpos - 1U;
      chrpos += Uintlist_head(q);
      secondpos = chrpos;
      support2 = get_support2(/*types*/Intlist_next(p),/*npositions*/Uintlist_next(q));

      add_splice(firstpos,secondpos,chr,nhits,support1,support2,
		 fwd_splices_chrtable,rev_splices_chrtable,
		 genome,chromosome_iit,truestrand);

      support1 = 0;

    } else if (type == 'I') {
      /* Do nothing */
      support1 += Uintlist_head(q);

    } else if (type == 'D') {
      /* CHECK */
      firstpos = chrpos - 1U;
      chrpos += Uintlist_head(q);
      secondpos = chrpos;
      if (secondpos - firstpos > 50) {
	support2 = get_support2(/*types*/Intlist_next(p),/*npositions*/Uintlist_next(q));

	add_splice(firstpos,secondpos,chr,nhits,support1,support2,
		   fwd_splices_chrtable,rev_splices_chrtable,
		   genome,chromosome_iit,truestrand);

	support1 = 0;
      }

    } else {
      fprintf(stderr,"Cannot parse type %c\n",type);
      exit(9);
    }
    debug(printf("  type = %c, chrpos = %u\n",type,chrpos));
  }


  return;
}


/************************************************************************
 *   Output
 ************************************************************************/

static void
print_extents (Uinttable_T sitetable, char *chr) {
  Genomicpos_T *keys;
  int n, i;
  Site_T site;

  if ((n = Uinttable_length(sitetable)) > 0) {
    keys = (Genomicpos_T *) Uinttable_keys(sitetable,/*sortp*/true);
    for (i = 0; i < n; i++) {
      site = Uinttable_get(sitetable,keys[i]);
      if (site == NULL) {
	fprintf(stderr,"key is %u, value is NULL\n",keys[i]);
	abort();
      } else {
	Site_print_extent(site,chr);
	Site_free_extent(&site);
      }
    }
    FREE(keys);
  }

  return;
}


static void
print_splices_sitetable (Uinttable_T sitetable, char *chr) {
  Genomicpos_T *keys;
  int n, i;
  Site_T site;

  n = Uinttable_length(sitetable);
  keys = (Genomicpos_T *) Uinttable_keys(sitetable,/*sortp*/true);
  for (i = 0; i < n; i++) {
    site = (Site_T) Uinttable_get(sitetable,keys[i]);
    if (site == NULL) {
      fprintf(stderr,"key is %u, value is NULL\n",keys[i]);
      abort();
    } else {
      Site_print_splice(site,chr);
      /* Site_free_splice(&site); */
    }
  }
  FREE(keys);

  return;
}

static void
print_splices_list (List_T splices, char *chr) {
  List_T p;

  for (p = splices; p != NULL; p = List_next(p)) {
    Splice_print((Splice_T) List_head(p),chr);
  }

  return;
}


static List_T
accumulate_splices (List_T splices, Uinttable_T sitetable) {
  Genomicpos_T *keys;
  Site_T site;
  List_T p;
  Splice_T splice;
  int n, i;

  n = Uinttable_length(sitetable);
  keys = (Genomicpos_T *) Uinttable_keys(sitetable,/*sortp*/true);
  for (i = 0; i < n; i++) {
    site = (Site_T) Uinttable_get(sitetable,keys[i]);
    for (p = site->intervals; p != NULL; p = List_next(p)) {
      splice = (Splice_T) List_head(p);
      if (splice->boundedp == true) {
	splices = List_push(splices,(void *) splice);
      }
    }
  }
  FREE(keys);

  return splices;
}


static int
strongest (Splice_T fwd_splice, Splice_T rev_splice, 
	   long int *fwd_runlengths, long int *rev_runlengths,
	   Splice_T *array, int a, int b, int nsplices, char *chr,
	   Genomicpos_T fwd_chrlength, Genomicpos_T rev_chrlength) {
  long int fwd_max, rev_max;
  int i;

  fwd_max = Tally_maxcount(fwd_runlengths,fwd_chrlength,fwd_splice->low,fwd_splice->high);
  rev_max = Tally_maxcount(rev_runlengths,rev_chrlength,rev_splice->low,rev_splice->high);
  if (fwd_max + 1 > 5*(rev_max + 1)) {
    fprintf(stderr,"Choose +%s:%u..%u (%ld) over -%s:%u..%u (%ld)\n",
	    chr,fwd_splice->low,fwd_splice->high,fwd_max,
	    chr,rev_splice->high,rev_splice->low,rev_max);
    return +1;
  } else if (rev_max + 1 > 5*(fwd_max + 1)) {
    fprintf(stderr,"Choose -%s:%u..%u (%ld) over +%s:%u..%u (%ld)\n",
	    chr,rev_splice->high,rev_splice->low,rev_max,
	    chr,fwd_splice->low,fwd_splice->high,fwd_max);
    return -1;
  } else {
    i = a-1;
    while (i >= 0 && array[i]->high + max_exonlength > fwd_splice->low && array[i]->high > rev_splice->low) {
      fwd_max = Tally_maxcount(fwd_runlengths,fwd_chrlength,array[i]->low,array[i]->high);
      rev_max = Tally_maxcount(rev_runlengths,rev_chrlength,array[i]->low,array[i]->high);
      if (fwd_max + 1 > 5*(rev_max + 1)) {
	fprintf(stderr,"Choose +%s:%u..%u (%ld) over -%s:%u..%u (%ld), secondary left\n",
		chr,fwd_splice->low,fwd_splice->high,fwd_max,
		chr,rev_splice->high,rev_splice->low,rev_max);
	return +1;
      } else if (rev_max + 1 > 5*(fwd_max + 1)) {
	fprintf(stderr,"Choose -%s:%u..%u (%ld) over +%s:%u..%u (%ld), secondary left\n",
		chr,rev_splice->high,rev_splice->low,rev_max,
		chr,fwd_splice->low,fwd_splice->high,fwd_max);
	return -1;
      }
      i--;
    }

    i = b+1;
    while (i < nsplices && array[i]->low < fwd_splice->high + max_exonlength && array[i]->low < rev_splice->high + max_exonlength) {
      fwd_max = Tally_maxcount(fwd_runlengths,fwd_chrlength,array[i]->low,array[i]->high);
      rev_max = Tally_maxcount(rev_runlengths,rev_chrlength,array[i]->low,array[i]->high);
      if (fwd_max + 1 > 5*(rev_max + 1)) {
	fprintf(stderr,"Choose +%s:%u..%u (%ld) over -%s:%u..%u (%ld), secondary right\n",
		chr,fwd_splice->low,fwd_splice->high,fwd_max,
		chr,rev_splice->high,rev_splice->low,rev_max);
	return +1;
      } else if (rev_max + 1 > 5*(fwd_max + 1)) {
	fprintf(stderr,"Choose -%s:%u..%u (%ld) over +%s:%u..%u (%ld), secondary right\n",
		chr,rev_splice->high,rev_splice->low,rev_max,
		chr,fwd_splice->low,fwd_splice->high,fwd_max);
	return -1;
      }
      i++;
    }
  }

  fprintf(stderr,"Cannot choose between +%s:%u..%u (%ld) and -%s:%u..%u (%ld)\n",
	  chr,fwd_splice->low,fwd_splice->high,fwd_max,chr,rev_splice->high,rev_splice->low,rev_max);

  return 0;
}


static bool
consistentp (Splice_T splice, long int *fwd_runlengths, long int *rev_runlengths,
	     char *chr, Genomicpos_T fwd_chrlength, Genomicpos_T rev_chrlength) {
  long int fwd_max, rev_max;

  fwd_max = Tally_maxcount(fwd_runlengths,fwd_chrlength,splice->low,splice->high);
  rev_max = Tally_maxcount(rev_runlengths,rev_chrlength,splice->low,splice->high);
  if (splice->sign > 0) {
    if (rev_max + 1 > 5*(fwd_max + 1)) {
      fprintf(stderr,"Inconsistent: +%s:%u..%u (%ld fwd, %ld rev)\n",
	      chr,splice->low,splice->high,fwd_max,rev_max);
      return false;
    }
  } else if (splice->sign < 0) {
    if (fwd_max + 1 > 5*(rev_max + 1)) {
      fprintf(stderr,"Inconsistent: -%s:%u..%u (%ld fwd, %ld rev)\n",
	      chr,splice->high,splice->low,fwd_max,rev_max);
      return false;
    }
  }

  return true;
}



static void
resolve_splices (Splice_T *array, int nsplices, long int *fwd_runlengths, long int *rev_runlengths,
		 Genomicpos_T fwd_chrlength, Genomicpos_T rev_chrlength, char *chr) {
  Splice_T splice1, splice2;
  int a, b;
  int result;


  qsort(array,nsplices,sizeof(Splice_T),Splice_low_cmp);
  for (a = 0; a < nsplices; a++) {
    splice1 = array[a];
    for (b = a+1; b < nsplices; b++) {
      splice2 = array[b];
      if (splice2->low > splice1->low + 20) {
	b = nsplices;	/* End loop */

      } else if (splice1->sign == splice2->sign) {
	/* Don't resolve between splices on the same strand */

      } else if (splice1->sign > 0) {
	if ((result = strongest(splice1,splice2,fwd_runlengths,rev_runlengths,array,a,b,nsplices,chr,
				fwd_chrlength,rev_chrlength)) > 0) {
	  splice2->boundedp = false;
	} else if (result < 0) {
	  splice1->boundedp = false;
	}
	      
      } else {
	if ((result = strongest(splice2,splice1,fwd_runlengths,rev_runlengths,array,a,b,nsplices,chr,
				fwd_chrlength,rev_chrlength)) > 0) {
	  splice1->boundedp = false;
	} else if (result < 0) {
	  splice2->boundedp = false;
	}
      }
    }
  }

  qsort(array,nsplices,sizeof(Splice_T),Splice_high_cmp);
  for (a = 0; a < nsplices; a++) {
    splice1 = array[a];
    for (b = a+1; b < nsplices; b++) {
      splice2 = array[b];
      if (splice2->high < splice1->high - 20) {
	b = nsplices;	/* End loop */

      } else if (splice1->sign == splice2->sign) {
	/* Don't resolve between splices on the same strand */

      } else if (splice1->sign > 0) {
	if ((result = strongest(splice1,splice2,fwd_runlengths,rev_runlengths,array,a,b,nsplices,chr,
				fwd_chrlength,rev_chrlength)) > 0) {
	  splice2->boundedp = false;
	} else if (result < 0) {
	  splice1->boundedp = false;
	}

      } else {
	if ((result = strongest(splice2,splice1,fwd_runlengths,rev_runlengths,array,a,b,nsplices,chr,
				fwd_chrlength,rev_chrlength)) > 0) {
	  splice1->boundedp = false;
	} else if (result < 0) {
	  splice2->boundedp = false;
	}
      }
    }
  }

  for (a = 0; a < nsplices; a++) {
    splice1 = array[a];
    if (splice1->boundedp == true) {
      if (consistentp(splice1,fwd_runlengths,rev_runlengths,chr,fwd_chrlength,rev_chrlength) == false) {
	splice1->boundedp = false;
      }
    }
  }

  return;
}



static void
turn_splices (Splice_T *array, int nsplices, char *chr) {
  int i, j, k;
  Splice_T splice, left_splice, right_splice;
  Splice_T *alpha_array, *omega_array;

  alpha_array = Splice_array_copy(array,nsplices);
  qsort(alpha_array,nsplices,sizeof(Splice_T),Splice_low_cmp);
  for (i = 0; i < nsplices; i++) {
    alpha_array[i]->alpha = i;
  }

  omega_array = Splice_array_copy(array,nsplices);
  qsort(omega_array,nsplices,sizeof(Splice_T),Splice_high_cmp);
  for (i = 0; i < nsplices; i++) {
    omega_array[i]->omega = i;
  }

  qsort(array,nsplices,sizeof(Splice_T),Splice_bycount_cmp);

  for (i = 0; i < nsplices; i++) {
    splice = array[i];
    if (splice->boundedp == true) {
      /* fprintf(stderr,"Splice %c%s:%u..%u (%d)\n",
	 splice->sign > 0 ? '+' : '-',chr,splice->donorpos,splice->acceptorpos,splice->count); */

      /* Get left splices */
      j = splice->omega;
      while (j < nsplices && omega_array[j]->high >= splice->low) {
	/* fprintf(stderr,"  advancing: omega %d, high %u\n",j,omega_array[j]->high); */
	j++;
      }
      for ( ; j < nsplices && omega_array[j]->high + max_exonlength >= splice->low; j++) {
	/* fprintf(stderr,"  evaluating: omega %d, high %u\n",j,omega_array[j]->high); */
	left_splice = omega_array[j];
	if (left_splice->boundedp == true) {

	  /* Get right splices */
	  k = splice->alpha + 1;
	  while (k < nsplices && alpha_array[k]->low <= splice->high) {
	    k++;
	  }
	  for ( ; k < nsplices && alpha_array[k]->low <= splice->high + max_exonlength; k++) {
	    right_splice = alpha_array[k];
	    if (right_splice->boundedp == true) {

#if 0
	      fprintf(stderr,"Splice %c%s:%u..%u (%d) compared with %c%s:%u..%u (%d) and  %c%s:%u..%u (%d)\n",
		      splice->sign > 0 ? '+' : '-',chr,splice->donorpos,splice->acceptorpos,splice->count,
		      left_splice->sign > 0 ? '+' : '-',chr,left_splice->donorpos,left_splice->acceptorpos,left_splice->count,
		      right_splice->sign > 0 ? '+' : '-',chr,right_splice->donorpos,right_splice->acceptorpos,right_splice->count);
#endif


	      if (left_splice->sign != right_splice->sign) {
#if 0
		fprintf(stderr,"Splices %c%s:%u..%u (%d) and %c%s:%u..%u (%d) are inconsistent\n",
			left_splice->sign > 0 ? '+' : '-',chr,left_splice->donorpos,left_splice->acceptorpos,left_splice->count,
			right_splice->sign > 0 ? '+' : '-',chr,right_splice->donorpos,right_splice->acceptorpos,right_splice->count);
#endif
	      } else if (splice->sign != left_splice->sign) {
		fprintf(stderr,"Splice %c%s:%u..%u (%d) eliminated by %c%s:%u..%u (%d) and  %c%s:%u..%u (%d)\n",
			splice->sign > 0 ? '+' : '-',chr,splice->donorpos,splice->acceptorpos,splice->count,
			left_splice->sign > 0 ? '+' : '-',chr,left_splice->donorpos,left_splice->acceptorpos,left_splice->count,
			right_splice->sign > 0 ? '+' : '-',chr,right_splice->donorpos,right_splice->acceptorpos,right_splice->count);
		splice->boundedp = false;
	      }
	    }
	  }
	}
      }
    }
  }

  FREE(omega_array);
  FREE(alpha_array);

  return;
}



static void
add_pairings (long int *cum, List_T extents) {
  List_T p;
  Extent_T extent;

  for (p = extents; p != NULL; p = List_next(p)) {
    extent = (Extent_T) List_head(p);
    cum[extent->low] += extent->count;
    /* This is at extent->high + 1, because we want to keep cum at extent->high */
    cum[extent->high + 1] -= extent->count;
  }

  return;
}


static void
print_runlengths (Uinttable_T sitetable, char *chr) {
  List_T p;
  Extent_T extent;
  Genomicpos_T chrlength = 0, lastpos, pos;
  long int *cum, level;
  Genomicpos_T *keys;
  Site_T site;
  int n, i;

  if ((n = Uinttable_length(sitetable)) > 0) {
    keys = Uinttable_keys(sitetable,/*sortp*/true);
    for (i = 0; i < n; i++) {
      site = (Site_T) Uinttable_get(sitetable,keys[i]);
      for (p = site->intervals; p != NULL; p = List_next(p)) {
	extent = (Extent_T) List_head(p);
	if (extent->high + 1 > chrlength) {
	  chrlength = extent->high + 1;
	}
      }
    }

    cum = (long int *) CALLOC(chrlength+1,sizeof(long int));
    for (i = 0; i < n; i++) {
      site = (Site_T) Uinttable_get(sitetable,keys[i]);
      add_pairings(cum,site->intervals);
    }

    FREE(keys);

    /* dump_cum(cum,chrlength); */

    /* Print runlengths */
    lastpos = 1U;
    level = 0;
    for (pos = 1; pos <= chrlength; pos++) {
      if (cum[pos] != 0) {
	/* printf("cum at pos %u is %d\n",pos,cum[pos]); */
	printf(">%ld %s:%u..%u\n",level,chr,lastpos,pos-1);
	level += cum[pos];
	lastpos = pos;
      }
    }

    /* Should print the final level of zero */
    printf(">%ld %s:%u..%u\n",level,chr,lastpos,pos-1);
    if (level != 0) {
      fprintf(stderr,"Ended with a non-zero level\n");
      abort();
    }

    FREE(cum);
  }

  return;
}

static void
sitetable_extent_gc (Uinttable_T *sitetable) {
  int n, i;
  Genomicpos_T *keys;
  Site_T site;

  n = Uinttable_length(*sitetable);
  keys = Uinttable_keys(*sitetable,/*sortp*/false);
  for (i = 0; i < n; i++) {
    site = (Site_T) Uinttable_get(*sitetable,keys[i]);
    Site_free_extent(&site);
  }

  FREE(keys);
  Uinttable_free(&(*sitetable));
  return;
}

static void
sitetable_splice_gc (Uinttable_T *sitetable) {
  int n, i;
  Genomicpos_T *keys;
  Site_T site;

  n = Uinttable_length(*sitetable);
  keys = Uinttable_keys(*sitetable,/*sortp*/false);
  for (i = 0; i < n; i++) {
    site = (Site_T) Uinttable_get(*sitetable,keys[i]);
    Site_free_splice(&site);
  }

  FREE(keys);
  Uinttable_free(&(*sitetable));
  return;
}


static long int *
store_runlength (Genomicpos_T *chrlength, Uinttable_T sitetable) {
  long int *cum, level;
  List_T p;
  Extent_T extent;
  Genomicpos_T lastpos, pos, x;
  Genomicpos_T *keys;
  Site_T site;
  int n, i;

  *chrlength = 0;
  if ((n = Uinttable_length(sitetable)) == 0) {
    *chrlength = 0;
    return (long int *) NULL;

  } else {
    keys = Uinttable_keys(sitetable,/*sortp*/true);
    for (i = 0; i < n; i++) {
      site = (Site_T) Uinttable_get(sitetable,keys[i]);
      for (p = site->intervals; p != NULL; p = List_next(p)) {
	extent = (Extent_T) List_head(p);
	if (extent->high + 1 > *chrlength) {
	  *chrlength = extent->high + 1;
	}
      }
    }

    cum = (long int *) CALLOC((*chrlength)+1,sizeof(long int));
    for (i = 0; i < n; i++) {
      site = (Site_T) Uinttable_get(sitetable,keys[i]);
      add_pairings(cum,site->intervals);
    }

    FREE(keys);

    /* Convert to runlengths */
    lastpos = 1U;
    level = 0;
    for (pos = 1; pos <= *chrlength; pos++) {
      if (cum[pos] != 0) {
	/* printf("cum at pos %u is %d\n",pos,cum[pos]); */
	/* printf(">%ld %s:%u..%u\n",level,chr,lastpos,pos-1); */
	for (x = lastpos; x < pos; x++) {
	  cum[x] = level;
	}

	level += cum[pos];
	lastpos = pos;
      }
    }

    /* Should print the final level of zero */
    if (level != 0) {
      fprintf(stderr,"Ended with a non-zero level\n");
      abort();
    } else {
      /* printf(">%ld %s:%u..%u\n",level,chr,lastpos,pos-1); */
      for (x = lastpos; x < pos; x++) {
	cum[x] = level;
      }
    }

    return cum;
  }
}



/************************************************************************
 *   Input
 ************************************************************************/

static char
combine_strands (char strand1, char strand2) {

  if (strand1 == '?' || strand2 == '?') {
    return '?';

  } else if (strand1 == ' ' && strand2 == ' ') {
    return ' ';

  } else if (strand1 == '+' && strand2 == '-') {
    /* Skip.  Inconsistent directions */
    return '?';

  } else if (strand1 == '-' && strand2 == '+') {
    /* Skip.  Inconsistent directions */
    return '?';

#if 0
  } else if (strcmp(chr1,chr2)) {
    /* Skip.  Inconsistent chromosomes */
    return '?';
#endif

  } else if (strand1 == ' ') {
    return strand2;

  } else if (strand2 == ' ') {
    return strand1;

  } else {
    return strand1;
  }
}



#ifdef BAM_INPUT


/* Modifies global tally variables */
static void
parse_bam_input (Bamreader_T bamreader, Table_T fwd_extents_chrtable, Table_T rev_extents_chrtable,
		 Table_T bamstore_chrtable, Table_T fwd_splices_chrtable, Table_T rev_splices_chrtable,
		 Genome_T genome, IIT_T chromosome_iit) {
  Bamline_T bamline, bamline_low;
  int nhits, nhits1, nhits2;
  unsigned int flag;
  bool pairedp, concordantp, firstp;
  char strand;

  while ((bamline = Bamread_next_bamline(bamreader)) != NULL) {
    flag = Bamline_flag(bamline);
    if (flag & QUERY_UNMAPPED) {
      concordantp = false;
    } else {
      if (!(flag & PAIRED_READ)) {
	pairedp = false;
	concordantp = false;
      } else if (flag & FIRST_READ_P) {
	pairedp = true;
	concordantp = (flag & PAIRED_MAPPING) ? true : false;
	firstp = true;
      } else if (flag & SECOND_READ_P) {
	pairedp = true;
	concordantp = (flag & PAIRED_MAPPING) ? true : false;
	firstp = false;
      } else {
	pairedp = true;
	fprintf(stderr,"Flag %u is paired (%u), but contains neither first_read nor second_read flag\n",
		flag,flag & PAIRED_READ);
	abort();
      }
    }

    if (concordantp == false) {
      Bamline_free(&bamline);
    } else if (uniquep == true && (nhits = Bamline_nhits(bamline)) != 1) {
      Bamline_free(&bamline);
    } else if (Bamline_mate_chrpos_low(bamline) > Bamline_chrpos_low(bamline)) {
      Bamstore_add_at_low(bamstore_chrtable,Bamline_chr(bamline),Bamline_chrpos_low(bamline),
			  bamline);
    } else {
      bamline_low = Bamstore_get(bamstore_chrtable,Bamline_chr(bamline),Bamline_mate_chrpos_low(bamline),
				 Bamline_acc(bamline),Bamline_chrpos_low(bamline));

      if (bamline_low != NULL) {
	nhits1 = Bamline_nhits(bamline_low);
	nhits2 = Bamline_nhits(bamline);
	if (nhits1 < nhits2) {
	  nhits = nhits1;
	} else {
	  nhits = nhits2;
	}

	strand = combine_strands(Bamline_strand(bamline_low,genome,chromosome_iit),
				 Bamline_strand(bamline,genome,chromosome_iit));

	parse_splices(Bamline_nhits(bamline_low),Bamline_chr(bamline_low),Bamline_chrpos_low(bamline_low),
		      Bamline_cigar_types(bamline_low),Bamline_cigar_npositions(bamline_low),
		      strand,fwd_splices_chrtable,rev_splices_chrtable,genome,chromosome_iit);

	parse_splices(Bamline_nhits(bamline),Bamline_chr(bamline),Bamline_chrpos_low(bamline),
		      Bamline_cigar_types(bamline),Bamline_cigar_npositions(bamline),
		      strand,fwd_splices_chrtable,rev_splices_chrtable,genome,chromosome_iit);

	Site_add_at_low(fwd_extents_chrtable,rev_extents_chrtable,Bamline_chr(bamline),Bamline_chrpos_low(bamline_low),
			Bamline_chrpos_high(bamline),nhits,strand);
	Bamline_free(&bamline_low);
      }
      Bamline_free(&bamline);
    }
  }

  return;
}



#else

static List_T
lines_gc (List_T *lines) {
  char *line;
  void *item;

  while (*lines != NULL) {
    *lines = List_pop(*lines,&item);
    line = (char *) item;
    FREE(line);
  }
  return NULL;
}


static void
parse_paired (char strand1, char strand2, char *chr1, char *chr2,
	      Genomicpos_T chrpos_low_1, Genomicpos_T chrpos_high_1,
	      Genomicpos_T chrpos_low_2, Genomicpos_T chrpos_high_2,
	      int nhits, Table_T fwd_extents_chrtable, Table_T rev_extents_chrtable) {
  char strand;
  Genomicpos_T chrpos_low, chrpos_high;

  strand = combine_strands(strand1,strand2);

  debug(printf("strand1 is %c.  strand2 is %c.  strand is %c.\n",strand1,strand2,strand));

  debug(printf("Got %c%u..%u and %c%u..%u\n",
	       strand1,chrpos_low_1,chrpos_high_1,strand2,chrpos_low_2,chrpos_high_2));
  if (chrpos_low_1 < chrpos_low_2) {
    chrpos_low = chrpos_low_1;
  } else {
    chrpos_low = chrpos_low_2;
  }
  
  if (chrpos_high_1 > chrpos_high_2) {
    chrpos_high = chrpos_high_1;
  } else {
    chrpos_high = chrpos_high_2;
  }

  Site_add_at_low(fwd_extents_chrtable,rev_extents_chrtable,chr1,chrpos_low,chrpos_high,nhits,strand);

  return;
}



static void
parse_line (char strand, char *chr, Genomicpos_T chrpos_low, Genomicpos_T *chrpos_high,
	    char *cigar, Genome_T genome, IIT_T chromosome_iit, int nhits,
	    Table_T fwd_splices_chrtable, Table_T rev_splices_chrtable) {
  Genomicpos_T chrpos, firstpos, secondpos;
  int cigar_readlength;
  int type;
  Intlist_T types, p;
  Uintlist_T npositions, q;

  bool canonicalp;
  bool splice_present_p = false;

  types = Samread_parse_cigar(&npositions,&cigar_readlength,cigar);

  chrpos = chrpos_low;
  for (p = types, q = npositions; p != NULL; p = Intlist_next(p), q = Uintlist_next(q)) {
    if ((type = Intlist_head(p)) == 'S') {
      /* Ignore */

    } else if (type == 'H') {
      /* Ignore */

    } else if (type == 'M') {
      chrpos += Uintlist_head(q);

    } else if (type == 'N') {
      firstpos = chrpos - 1U;
      chrpos += Uintlist_head(q);
      secondpos = chrpos;
      splice_present_p = true;

    } else if (type == 'I') {
      /* Do nothing */

    } else if (type == 'D') {
      /* CHECK */
      chrpos += Uintlist_head(q);

    } else {
      fprintf(stderr,"Cannot parse type %c\n",type);
      exit(9);
    }
    debug(printf("  type = %c, chrpos = %u\n",type,chrpos));
  }

  if (splice_present_p == true) {
    parse_splices(nhits,chr,chrpos_low,types,npositions,strand,
		  fwd_splices_chrtable,rev_splices_chrtable,
		  genome,chromosome_iit);
  }


  Intlist_free(&types);
  Uintlist_free(&npositions);

  *chrpos_high = chrpos - 1U;

  /* FREE(*chr); */

  return;
}


static void
process_lines (Table_T fwd_extents_chrtable, Table_T rev_extents_chrtable,
	       Table_T fwd_splices_chrtable, Table_T rev_splices_chrtable,
	       List_T lines_first, List_T lines_second, int nhits1, int nhits2,
	       bool concordantp, Genome_T genome, IIT_T chromosome_iit) {
  List_T ptr1, ptr2;
  char *line1, *line2;
  int nhits;

  char *auxinfo;
  char strand, strand1, strand2;
  char *chr1, *chr2;
  Genomicpos_T chrpos_low_1, chrpos_high_1, chrpos_low_2, chrpos_high_2;

  unsigned int flag;
  char *acc, *read, *quality_string, *cigar1, *cigar2;
  int readlength;
  int mapq;


  debug0(printf("Entering process_lines with nhits %d\n",nhits));

  ptr1 = lines_first;
  ptr2 = lines_second;
  while (ptr1 != NULL && ptr2 != NULL) {
    line1 = (char *) List_head(ptr1);
    line2 = (char *) List_head(ptr2);
    if (nhits1 < nhits2) {
      nhits = nhits1;
    } else {
      nhits = nhits2;
    }

    auxinfo = Samread_parse_line(&acc,&flag,&mapq,&chr1,&chrpos_low_1,&cigar1,&readlength,&read,&quality_string,line1);
    strand1 = Samread_splice_strand(auxinfo);
    FREE(acc);
    FREE(read);
    FREE(quality_string);

    auxinfo = Samread_parse_line(&acc,&flag,&mapq,&chr2,&chrpos_low_2,&cigar2,&readlength,&read,&quality_string,line2);
    strand2 = Samread_splice_strand(auxinfo);
    FREE(acc);
    FREE(read);
    FREE(quality_string);

    strand = combine_strands(strand1,strand2);

    parse_line(strand,chr1,chrpos_low_1,&chrpos_high_1,cigar1,genome,chromosome_iit,
	       nhits1,fwd_splices_chrtable,rev_splices_chrtable);
    parse_line(strand,chr2,chrpos_low_2,&chrpos_high_2,cigar2,genome,chromosome_iit,
	       nhits2,fwd_splices_chrtable,rev_splices_chrtable);
    FREE(cigar2);
    FREE(cigar1);

    parse_paired(strand1,strand2,chr1,chr2,chrpos_low_1,chrpos_high_1,
		 chrpos_low_2,chrpos_high_2,nhits,fwd_extents_chrtable,rev_extents_chrtable);
    FREE(chr2);
    FREE(chr1);

    ptr1 = List_next(ptr1);
    ptr2 = List_next(ptr2);
  }

  return;
}


/* Modifies global tally variables */
static void
parse_sam_input (Table_T fwd_extents_chrtable, Table_T rev_extents_chrtable,
		 Table_T fwd_splices_chrtable, Table_T rev_splices_chrtable,
		 Genome_T genome, IIT_T chromosome_iit) {
  List_T lines_first = NULL, lines_second = NULL;
  char line[1024000], *copy;
  int nhits_first = 0, nhits_second = 0;
  char *lastacc, *acc;
  unsigned int flag;
  bool pairedp, concordantp;

  lastacc = (char *) CALLOC(1,sizeof(char));
  lastacc[0] = '\0';

  while (fgets(line,1024000,stdin) != NULL) {
    if (line[0] == '@') {
      /* Skip */
    } else {
      acc = Samread_get_acc(&flag,line);
      if (strcmp(acc,lastacc)) {
	if (lastacc[0] != '\0') {
	  if (concordantp == true) {
	    if (uniquep == false || (nhits_first == 1 && nhits_second == 1)) {
	      process_lines(fwd_extents_chrtable,rev_extents_chrtable,
			    fwd_splices_chrtable,rev_splices_chrtable,
			    lines_first,lines_second,nhits_first,nhits_second,
			    concordantp,genome,chromosome_iit);
	    }
	  }
	  lines_first = lines_gc(&lines_first);
	  lines_second = lines_gc(&lines_second);
	  nhits_first = 0;
	  nhits_second = 0;
	}
	FREE(lastacc);
	lastacc = acc;
      } else {
	FREE(acc);
      }

      if (flag & QUERY_UNMAPPED) {
	/* Skip line */
      } else {
	copy = (char *) CALLOC(strlen(line)+1,sizeof(char));
	strcpy(copy,line);
	if (!(flag & PAIRED_READ)) {
	  pairedp = false;
	  concordantp = false;
	  lines_first = List_push(lines_first,(void *) copy);
	  nhits_first++;
	} else if (flag & FIRST_READ_P) {
	  pairedp = true;
	  concordantp = (flag & PAIRED_MAPPING) ? true : false;
	  lines_first = List_push(lines_first,(void *) copy);
	  nhits_first++;
	} else if (flag & SECOND_READ_P) {
	  pairedp = true;
	  concordantp = (flag & PAIRED_MAPPING) ? true : false;
	  lines_second = List_push(lines_second,(void *) copy);
	  nhits_second++;
	} else {
	  pairedp = true;
	  fprintf(stderr,"Flag %u is paired (%u), but contains neither first_read nor second_read flag\n",
		  flag,flag & PAIRED_MAPPING);
	  abort();
	}
      }
    }
  }

  if (lastacc[0] != '\0') {
    if (concordantp == true) {
      if (uniquep == false || (nhits_first == 1 && nhits_second == 1)) {
	process_lines(fwd_extents_chrtable,rev_extents_chrtable,
		      fwd_splices_chrtable,rev_splices_chrtable,
		      lines_first,lines_second,nhits_first,nhits_second,
		      concordantp,genome,chromosome_iit);
      }
    }
    lines_first = lines_gc(&lines_first);
    lines_second = lines_gc(&lines_second);
  }
  FREE(lastacc);

  return;
}

#endif

int
main (int argc, char *argv[]) {
  char *genomesubdir = NULL, *fileroot = NULL;
  Table_T fwd_extents_chrtable, rev_extents_chrtable, fwd_splices_chrtable, rev_splices_chrtable;
  Uinttable_T sitetable;
  Chrom_T *fwd_keys, *rev_keys, chrom;
  int fwd_n, rev_n, nsplices, i, j;
  int cmp;
  List_T splices;
  long int *fwd_runlengths, *rev_runlengths;
  Genomicpos_T fwd_chrlength, rev_chrlength;
  Splice_T *array;

#ifdef BAM_INPUT
  int n;
  Chrom_T *keys;
  Table_T bamstore_chrtable;
  Bamreader_T bamreader;
  Uinttable_T bamstore_table;
#endif
  char *iitfile;
  IIT_T chromosome_iit = NULL;
  Genome_T genome = NULL;

  int opt;
  extern int optind;
  extern char *optarg;
  int long_option_index = 0;

  while ((opt = getopt_long(argc,argv,"D:d:C:U:P:V?",
			    long_options, &long_option_index)) != -1) {
    switch (opt) {

    case 'D': user_genomedir = optarg; break;
    case 'd': 
      dbroot = (char *) CALLOC(strlen(optarg)+1,sizeof(char));
      strcpy(dbroot,optarg);
      break;

    case 'C':
      switch (atoi(optarg)) {
      case 0: need_concordant_p = false; break;
      case 1: need_concordant_p = true; break;
      default: fprintf(stderr,"Concordant mode %s not recognized.\n",optarg); exit(9);
      }
      break;

    case 'U':
      switch (atoi(optarg)) {
      case 0: uniquep = false; break;
      case 1: uniquep = true; break;
      default: fprintf(stderr,"Unique mode %s not recognized.\n",optarg); exit(9);
      }
      break;

    case 'P': max_pairlength = atoi(optarg); break;

    case 'V': print_program_version(); exit(0);
    case '?': print_program_usage(); exit(0);
    default: exit(9);
    }
  }
  argc -= optind;
  argv += optind;


  if (dbroot != NULL) {
    genomesubdir = Datadir_find_genomesubdir(&fileroot,&dbversion,user_genomedir,dbroot);

    iitfile = (char *) CALLOC(strlen(genomesubdir)+strlen("/")+
			      strlen(fileroot)+strlen(".chromosome.iit")+1,sizeof(char));
    sprintf(iitfile,"%s/%s.chromosome.iit",genomesubdir,fileroot);
    chromosome_iit = IIT_read(iitfile,/*name*/NULL,/*readonlyp*/true,/*divread*/READ_ALL,
			      /*divstring*/NULL,/*add_iit_p*/false,/*labels_read_p*/true);
    FREE(iitfile);

    genome = Genome_new(genomesubdir,fileroot,/*snps_root*/NULL,/*uncompressedp*/false,
			/*access*/USE_MMAP_ONLY);
  }

  fwd_extents_chrtable = Table_new(100,Chrom_compare_table,Chrom_hash_table);
  rev_extents_chrtable = Table_new(100,Chrom_compare_table,Chrom_hash_table);

  fwd_splices_chrtable = Table_new(100,Chrom_compare_table,Chrom_hash_table);
  rev_splices_chrtable = Table_new(100,Chrom_compare_table,Chrom_hash_table);


#ifdef BAM_INPUT
  bamstore_chrtable = Table_new(100,Chrom_compare_table,Chrom_hash_table);
  bamreader = Bamread_new(argv[0]);
  parse_bam_input(bamreader,fwd_extents_chrtable,rev_extents_chrtable,
		  bamstore_chrtable,fwd_splices_chrtable,rev_splices_chrtable,
		  genome,chromosome_iit);
  Bamread_free(&bamreader);
#else
  parse_sam_input(fwd_extents_chrtable,rev_extents_chrtable,
		  fwd_splices_chrtable,rev_splices_chrtable,
		  genome,chromosome_iit);
#endif


  /* Fwd extents */
  fwd_keys = (Chrom_T *) Table_keys(fwd_extents_chrtable,NULL);
  if ((fwd_n = Table_length(fwd_extents_chrtable)) > 0) {
    qsort(fwd_keys,fwd_n,sizeof(Chrom_T),Chrom_compare_chrom);
  }

  rev_keys = (Chrom_T *) Table_keys(rev_extents_chrtable,NULL);
  if ((rev_n = Table_length(rev_extents_chrtable)) > 0) {
    qsort(rev_keys,rev_n,sizeof(Chrom_T),Chrom_compare_chrom);
  }

  i = j = 0;
  while (i < fwd_n && j < rev_n) {
    if ((cmp = Chrom_compare_chrom(&(fwd_keys[i]),&(rev_keys[j]))) < 0) {
      /* No rev extents: Print all fwd splices */
      splices = accumulate_splices((List_T) NULL,(Uinttable_T) Table_get(fwd_splices_chrtable,(void *) fwd_keys[i]));
      print_splices_list(splices,/*chr*/Chrom_string(fwd_keys[i]));
      List_free(&splices);
      i++;
    } else if (cmp > 0) {
      /* No fwd extents: Print all rev splices */
      splices = accumulate_splices((List_T) NULL,(Uinttable_T) Table_get(rev_splices_chrtable,(void *) rev_keys[j]));
      print_splices_list(splices,/*chr*/Chrom_string(rev_keys[j]));
      List_free(&splices);
      j++;
    } else {
      fwd_runlengths = store_runlength(&fwd_chrlength,(Uinttable_T) Table_get(fwd_extents_chrtable,(void *) fwd_keys[i]));
      rev_runlengths = store_runlength(&rev_chrlength,(Uinttable_T) Table_get(rev_extents_chrtable,(void *) rev_keys[j]));

      splices = accumulate_splices((List_T) NULL,(Uinttable_T) Table_get(fwd_splices_chrtable,(void *) fwd_keys[i]));
      splices = accumulate_splices(splices,(Uinttable_T) Table_get(rev_splices_chrtable,(void *) rev_keys[j]));

      nsplices = List_length(splices);
      fprintf(stderr,"chr %s has %d splices\n",Chrom_string(fwd_keys[i]),nsplices);
      array = (Splice_T *) List_to_array(splices,NULL);
      List_free(&splices);

      resolve_splices(array,nsplices,fwd_runlengths,rev_runlengths,fwd_chrlength,rev_chrlength,
		      /*chr*/Chrom_string(fwd_keys[i]));
      turn_splices(array,nsplices,/*chr*/Chrom_string(fwd_keys[i]));

      print_splices_sitetable((Uinttable_T) Table_get(fwd_splices_chrtable,(void *) fwd_keys[i]),Chrom_string(fwd_keys[i]));
      print_splices_sitetable((Uinttable_T) Table_get(rev_splices_chrtable,(void *) rev_keys[j]),Chrom_string(rev_keys[j]));

      FREE(array);
      FREE(rev_runlengths);
      FREE(fwd_runlengths);

      i++;
      j++;
    }
  }

  while (i < fwd_n) {
    splices = accumulate_splices((List_T) NULL,(Uinttable_T) Table_get(fwd_splices_chrtable,(void *) fwd_keys[i]));
    print_splices_list(splices,/*chr*/Chrom_string(fwd_keys[i]));
    List_free(&splices);
    i++;
  }

  while (i < rev_n) {
    splices = accumulate_splices((List_T) NULL,(Uinttable_T) Table_get(rev_splices_chrtable,(void *) rev_keys[j]));
    print_splices_list(splices,/*chr*/Chrom_string(rev_keys[j]));
    List_free(&splices);
    j++;
  }


  /* Free fwd extents */
  for (i = 0; i < fwd_n; i++) {
    chrom = fwd_keys[i];
    sitetable = Table_get(fwd_extents_chrtable,(void *) chrom);
    sitetable_extent_gc(&sitetable);
  }
  for (i = 0; i < fwd_n; i++) {
    Chrom_free(&(fwd_keys[i]));
  }
  FREE(fwd_keys);
  Table_free(&fwd_extents_chrtable);

  /* Free rev extents */
  for (i = 0; i < rev_n; i++) {
    chrom = rev_keys[i];
    sitetable = Table_get(rev_extents_chrtable,(void *) chrom);
    sitetable_extent_gc(&sitetable);
  }
  for (i = 0; i < rev_n; i++) {
    Chrom_free(&(rev_keys[i]));
  }
  FREE(rev_keys);
  Table_free(&rev_extents_chrtable);


  /* Free fwd splices */
  fwd_n = Table_length(fwd_splices_chrtable);
  fwd_keys = (Chrom_T *) Table_keys(fwd_splices_chrtable,NULL);
  for (i = 0; i < fwd_n; i++) {
    chrom = fwd_keys[i];
    sitetable = Table_get(fwd_splices_chrtable,(void *) chrom);
    sitetable_splice_gc(&sitetable);
  }
  for (i = 0; i < fwd_n; i++) {
    Chrom_free(&(fwd_keys[i]));
  }
  FREE(fwd_keys);
  Table_free(&fwd_splices_chrtable);

  /* Free rev splices */
  rev_n = Table_length(rev_splices_chrtable);
  rev_keys = (Chrom_T *) Table_keys(rev_splices_chrtable,NULL);
  for (i = 0; i < rev_n; i++) {
    chrom = rev_keys[i];
    sitetable = Table_get(rev_splices_chrtable,(void *) chrom);
    sitetable_splice_gc(&sitetable);
  }
  for (i = 0; i < rev_n; i++) {
    Chrom_free(&(rev_keys[i]));
  }
  FREE(rev_keys);
  Table_free(&rev_splices_chrtable);


#ifdef BAM_INPUT
  if ((n = Table_length(bamstore_chrtable)) > 0) {
    keys = (Chrom_T *) Table_keys(bamstore_chrtable,NULL);
    for (i = 0; i < n; i++) {
      chrom = keys[i];
      bamstore_table = Table_get(bamstore_chrtable,(void *) chrom);
      Bamstore_table_free(bamstore_table);
      Uinttable_free(&bamstore_table);
    }
    for (i = 0; i < n; i++) {
      Chrom_free(&(keys[i]));
    }
    FREE(keys);
  }
  Table_free(&bamstore_chrtable);
#endif

  Genome_free(&genome);
  IIT_free(&chromosome_iit);

  if (genomesubdir != NULL) {
    FREE(fileroot);
    FREE(dbversion);
    FREE(genomesubdir);
  }

  if (dbroot != NULL) {
    FREE(dbroot);
  }

  return 0;
}

